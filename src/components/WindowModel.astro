---
import "../styles/global.css";
---

<div id="window-container" class="w-1/2 h-full"></div>

<script>
  import * as THREE from "three";
  import { RapierPhysics } from "three/addons/physics/RapierPhysics.js";
  import { toonOutlinePass } from "three/tsl";

  let container;
  let camera, scene, renderer, stats;
  const frustumSize = 5;
  let physics, position;

  let boxes, spheres;
  let containerRect;

  init();

  function getContainerRect() {
    if (!container) {
      console.error("Container element not found");
      return null;
    }
    return container.getBoundingClientRect();
  }

  async function init() {
    container = document.getElementById("window-container");
    if (!container) {
      console.error("Container element not found");
      return;
    }

    containerRect = getContainerRect();
    if (!containerRect) {
      console.error("Container dimensions could not be determined");
      return;
    }

    console.log("Container dimensions:", containerRect);

    physics = await RapierPhysics();
    position = new THREE.Vector3();

    const aspect = containerRect.width / containerRect.height;
    camera = new THREE.OrthographicCamera(
      (frustumSize * aspect) / -2,
      (frustumSize * aspect) / 2,
      frustumSize / 2,
      frustumSize / -2,
      0.1,
      100
    );
    camera.lookAt(0, 0, 0);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x666666);

    const hemiLight = new THREE.HemisphereLight();
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 3);
    dirLight.position.set(5, 5, 5);
    dirLight.castShadow = true;
    dirLight.shadow.camera.zoom = 2;
    scene.add(dirLight);

    const floorCollider = new THREE.Mesh(
      new THREE.BoxGeometry(10, 1, 10),
      new THREE.MeshBasicMaterial({ color: "rgb(255,0,0)" })
    );
    floorCollider.position.y = -3;
    floorCollider.userData.physics = { mass: 0 };
    floorCollider.visible = false;
    scene.add(floorCollider);

    //

    const material = new THREE.MeshToonMaterial();

    const matrix = new THREE.Matrix4();
    const color = new THREE.Color();

    // Boxes

    const geometryBox = new THREE.BoxGeometry(0.075, 0.075, 0.075);
    boxes = new THREE.InstancedMesh(geometryBox, material, 400);
    boxes.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // will be updated every frame
    boxes.castShadow = true;
    boxes.receiveShadow = true;
    boxes.userData.physics = { mass: 1 };
    scene.add(boxes);

    for (let i = 0; i < boxes.count; i++) {
      matrix.setPosition(
        Math.random() - 0.5,
        Math.random() * 2,
        Math.random() - 0.5
      );
      boxes.setMatrixAt(i, matrix);
      boxes.setColorAt(i, color.setHex(0xffffff * Math.random()));
    }

    // Spheres

    const geometrySphere = new THREE.IcosahedronGeometry(0.05, 4);
    spheres = new THREE.InstancedMesh(geometrySphere, material, 400);
    spheres.instanceMatrix.setUsage(THREE.DynamicDrawUsage); // will be updated every frame
    spheres.castShadow = true;
    spheres.receiveShadow = true;
    spheres.userData.physics = { mass: 1 };
    scene.add(spheres);

    for (let i = 0; i < spheres.count; i++) {
      matrix.setPosition(
        Math.random() - 0.5,
        Math.random() * 2,
        Math.random() - 0.5
      );
      spheres.setMatrixAt(i, matrix);
      spheres.setColorAt(i, color.setHex(0xffffff * Math.random()));
    }

    physics.addScene(scene);

    //

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(containerRect.width, containerRect.height);
    renderer.setAnimationLoop(animate);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    //

    // postProcessing = new THREE.PostProcessing(renderer);

    // postProcessing.outputNode = toonOutlinePass(scene, camera);

    setInterval(() => {
      let index = Math.floor(Math.random() * boxes.count);

      position.set(0, Math.random() + 1, 0);
      physics.setMeshPosition(boxes, position, index);

      //

      index = Math.floor(Math.random() * spheres.count);

      position.set(0, Math.random() + 1, 0);
      physics.setMeshPosition(spheres, position, index);
    }, 1000 / 60);

    window.addEventListener("resize", onWindowResize);
  }

  function onWindowResize() {
    containerRect = getContainerRect();
    if (!containerRect) {
      return;
    }

    const aspect = containerRect.width / containerRect.height;

    camera.left = (-frustumSize * aspect) / 2;
    camera.right = (frustumSize * aspect) / 2;
    camera.top = frustumSize / 2;
    camera.bottom = -frustumSize / 2;

    camera.updateProjectionMatrix();

    renderer.setSize(containerRect.width, containerRect.height);
  }

  function animate() {
    renderer.render(scene, camera);
  }
</script>
