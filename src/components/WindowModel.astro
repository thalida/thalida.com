---
import "../styles/global.css";
---

<canvas id="matter-canvas" width="800" height="600"></canvas>

<script>
  import * as Matter from "matter-js";
  import polyDecomp from "poly-decomp";
  import "pathseg";

  init();

  function HSLToRGB(h: number, s: number, l: number) {
    s /= 100;
    l /= 100;
    const k = (n: number) => (n + h / 30) % 12;
    const a = s * Math.min(l, 1 - l);
    const f = (n: number) =>
      l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
    return [255 * f(0), 255 * f(8), 255 * f(4)];
  }

  function generateLightningBolt(
    startX: number,
    startY: number,
    endX: number,
    endY: number
  ) {
    const distance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
    const segments = Math.ceil(distance / 25); // Number of segments based on distance
    const pathPoints = [];

    // Generate the main path points for the lightning line
    for (let i = 0; i <= segments; i++) {
      const progress = i / segments;
      const randomXShift = Matter.Common.random(-20, 20);
      const x = startX + (endX - startX) * progress + randomXShift;
      const y = startY + (endY - startY) * progress;
      pathPoints.push({ x, y });
    }

    return pathPoints;
  }

  function calculateClockPosition() {
    const currentTime = new Date();

    const offset = 90; // Offset to align with the top of the clock

    // Calculate the angles for hour, minute, and second hands
    const hours = currentTime.getHours() % 12;
    const minutes = currentTime.getMinutes();
    const seconds = currentTime.getSeconds();
    // const hours = 6;
    // const minutes = 0;
    // const seconds = 0;

    const degreesPerHour = 360 / 12; // 12 hours on a clock
    const degreesPerMinute = 360 / 60; // 60 minutes on a clock
    const degreesPerSecond = 360 / 60; // 60 seconds on a clock

    const hourDegrees =
      hours * degreesPerHour + (minutes / 60) * degreesPerHour;
    const minuteDegrees = minutes * degreesPerMinute;
    const secondDegrees = seconds * degreesPerSecond;

    // Convert degrees to radians
    const hourRadians = (Math.PI * (hourDegrees + offset)) / 180;
    const minuteRadians = (Math.PI * (minuteDegrees + offset)) / 180;
    const secondRadians = (Math.PI * (secondDegrees + offset)) / 180;

    return {
      hour: hourRadians,
      minute: minuteRadians,
      second: secondRadians,
    };
  }

  function init() {
    // module aliases
    var Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Composite = Matter.Composite,
      Composites = Matter.Composites,
      Events = Matter.Events,
      Common = Matter.Common,
      Constraint = Matter.Constraint,
      Query = Matter.Query,
      Svg = Matter.Svg,
      Vertices = Matter.Vertices;

    Common.setDecomp(polyDecomp);

    // create an engine
    var engine = Engine.create({ enableSleeping: false });
    var world = engine.world;

    var canvas = document.getElementById("matter-canvas") as HTMLCanvasElement;
    var canvasWidth = canvas.width;
    var canvasHeight = canvas.height;

    if (!canvas) {
      console.error("canvas element not found");
      return;
    }

    // create a renderer
    var render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: canvasWidth,
        height: canvasHeight,
        // wireframes: true,
        wireframes: false,
        pixelRatio: window.devicePixelRatio || 1,
        // showAxes: true,
      },
    });

    Render.run(render);

    // create runner
    var runner = Runner.create();
    Runner.run(runner, engine);

    // define our categories (as bit fields, there are up to 32 available)
    var defaultCategory = 0x0001,
      clockCategory = 0x0002,
      percipitationCategory = 0x0004,
      lightningCategory = 0x0008;

    const clockLayer = Composite.create({
      label: "Clock Layer",
    });
    Composite.add(world, clockLayer);

    const percipitationLayer = Composite.create({
      label: "Percipitation Layer",
    });
    Composite.add(world, percipitationLayer);

    const lightningLayer = Composite.create({
      label: "Lightning Layer",
    });
    Composite.add(world, lightningLayer);

    function segmentBody() {
      const segmentBodyPart1 = Bodies.rectangle(200, 200, 100, 25, {
        chamfer: { radius: 25 / 2 },
      });
      const segmentBodyPart2 = Bodies.rectangle(200, 275, 100, 25, {
        chamfer: { radius: 25 / 2 },
      });
      const segmentBodyPart3 = Bodies.rectangle(200, 275 + 75, 100, 25, {
        chamfer: { radius: 25 / 2 },
      });

      const segmentBodyPart4 = Bodies.rectangle(
        250 - Math.floor(25 / 2),
        250 - 25 / 2,
        25,
        100,
        {
          chamfer: { radius: 25 / 2 },
        }
      );

      const segmentBodyPart5 = Bodies.rectangle(
        250 - 25 / 2,
        325 - 25 / 2,
        25,
        100,
        {
          chamfer: { radius: 25 / 2 },
        }
      );

      const segmentBodyPart6 = Bodies.rectangle(
        175 - 25 / 2,
        250 - 25 / 2,
        25,
        100,
        {
          chamfer: { radius: 25 / 2 },
        }
      );

      const segmentBodyPart7 = Bodies.rectangle(
        175 - 25 / 2,
        325 - 25 / 2,
        25,
        100,
        {
          chamfer: { radius: 25 / 2 },
        }
      );

      const segmentBody = Body.create({
        collisionFilter: {
          category: clockCategory,
        },
        isStatic: true,
        parts: [
          segmentBodyPart1,
          segmentBodyPart2,
          segmentBodyPart3,
          segmentBodyPart4,
          segmentBodyPart5,
          segmentBodyPart6,
          segmentBodyPart7,
        ],
      });

      return segmentBody;
    }

    const displayBodies = segmentBody();

    Composite.add(clockLayer, displayBodies);

    // Create the clock hands
    const hourHandLength = 200; // Length of the hour hand
    const minuteHandLength = 250; // Length of the minute hand
    const handWidth = 20; // Width of the hands
    const overlap = 10; // Overlap between the hands and the center
    var hourBody = Bodies.rectangle(
      400 - hourHandLength / 2 + overlap,
      300,
      hourHandLength + overlap,
      handWidth,
      {
        collisionFilter: {
          category: clockCategory,
        },
        isStatic: true,
        render: { fillStyle: "transparent", strokeStyle: "#ddd", lineWidth: 1 },
        chamfer: {
          radius: handWidth / 2,
        },
      }
    );
    Body.setCentre(hourBody, { x: hourHandLength / 2 - overlap, y: 0 }, true);

    var minuteBody = Bodies.rectangle(
      400 - minuteHandLength / 2 + overlap,
      300,
      minuteHandLength + overlap,
      handWidth,
      {
        collisionFilter: {
          category: clockCategory,
        },
        isStatic: true,
        render: { fillStyle: "transparent", strokeStyle: "#ddd", lineWidth: 1 },
        chamfer: {
          radius: handWidth / 2,
        },
      }
    );
    Body.setCentre(
      minuteBody,
      { x: minuteHandLength / 2 - overlap, y: 0 },
      true
    );

    var handsCenter = Bodies.rectangle(400, 300, 10, 10, {
      collisionFilter: {
        category: clockCategory,
      },
      isStatic: true,
      render: { fillStyle: "transparent", strokeStyle: "#ddd", lineWidth: 1 },
      chamfer: { radius: 5 },
    });

    // Set the position of the hour and minute hands based on the current time
    const clockPosition = calculateClockPosition();
    Body.setAngle(hourBody, clockPosition.hour);
    Body.setAngle(minuteBody, clockPosition.minute);

    Composite.add(clockLayer, [hourBody, minuteBody, handsCenter]);
    Composite.add(world, clockLayer);
    Render.run(render);

    // Create walls
    Composite.add(world, [
      // top wall
      Bodies.rectangle(400, 0, 800, 20, {
        isStatic: true,
        render: { fillStyle: "transparent" },
      }),
      // bottom wall
      Bodies.rectangle(400, 600, 800, 4, {
        isStatic: true,
        render: { fillStyle: "transparent", strokeStyle: "#333", lineWidth: 1 },
      }),
      // right wall
      Bodies.rectangle(800, 300, 4, 600, {
        isStatic: true,
        render: { fillStyle: "transparent" },
      }),
      // left wall
      Bodies.rectangle(0, 300, 4, 600, {
        isStatic: true,
        render: { fillStyle: "transparent" },
      }),
    ]);

    Render.lookAt(render, {
      min: { x: 0, y: 0 },
      max: { x: 800, y: 600 },
    });

    Events.on(runner, "tick", function (event) {
      // Update the clock hands every second
      if (event.timestamp % 1000 < 50) {
        const clockPosition = calculateClockPosition();
        Body.setAngle(hourBody, clockPosition.hour);
        Body.setAngle(minuteBody, clockPosition.minute);
      }

      const isRaining = true;
      if (isRaining) {
        const rainIntensity = 0.3; // Rain intensity (0 to 1))
        const randomRainIntensity = Common.random(0, 1);
        if (randomRainIntensity < rainIntensity) {
          const maxBodies = 1000; // Maximum number of raindrops
          const currentBodies = Composite.allBodies(percipitationLayer).length;
          if (currentBodies >= maxBodies) {
            // Remove the oldest raindrop if the limit is reached
            Composite.remove(
              percipitationLayer,
              Composite.allBodies(percipitationLayer)[0]
            );
          }

          // Create raindrops
          const x = Common.random(0.0, 800.0);
          const y = 0;
          const width = Common.random(2, 4);
          const height = Common.random(4, 8);
          const lightness = Common.random(60, 50);
          const rgbColor = HSLToRGB(200, 50, lightness);
          const raindrop = Bodies.rectangle(x, y, width, height, {
            collisionFilter: {
              category: percipitationCategory,
              mask: defaultCategory | clockCategory | percipitationCategory,
            },
            chamfer: {
              radius: Math.min(width, height) / 2,
            },
            friction: 0.0001,
            frictionAir: 0.01,
            restitution: 0.5,
            density: 0.001,
            render: {
              fillStyle: "transparent",
              lineWidth: 1,
              strokeStyle: `rgb(${rgbColor[0]}, ${rgbColor[1]}, ${rgbColor[2]})`,
            },
          });

          Composite.add(percipitationLayer, raindrop);
        }
      }

      const isLightning = true; // Force lightning for demonstration
      if (isLightning) {
        const baseLightningIntensity = 0.01; // Lightning intensity (0 to 1)
        const numLightningBolts = Composite.allBodies(lightningLayer).length;
        const lightningIntensity =
          baseLightningIntensity * (1 / (numLightningBolts + 1));
        const randomLightningIntensity = Common.random(0, 1);

        if (randomLightningIntensity < lightningIntensity) {
          const startX = Common.random(50, 750);
          const startY = Common.random(0, 100);
          let endX = startX + Common.random(-100, 100);
          let endY = Common.random(400, 580);

          const clockBodies = Composite.allBodies(clockLayer);
          const collisions = Query.ray(
            clockBodies,
            {
              x: startX,
              y: startY,
            },
            {
              x: endX,
              y: endY,
            }
          );
          if (collisions.length > 0) {
            // If the lightning intersects with the clock, adjust the end point
            const collisionPoint = collisions[0].supports[0];
            endX = collisionPoint.x;
            endY = collisionPoint.y;
          }

          // Generate lightning bolt path points
          const lightningPath = generateLightningBolt(
            startX,
            startY,
            endX,
            endY
          );

          // Create line segments connecting each point
          const lightningBodies: Matter.Body[] = [];
          for (let i = 0; i < lightningPath.length - 1; i++) {
            const point1 = lightningPath[i];
            const point2 = lightningPath[i + 1];

            // Calculate the center point and dimensions for the line segment
            const centerX = (point1.x + point2.x) / 2;
            const centerY = (point1.y + point2.y) / 2;
            const dx = point2.x - point1.x;
            const dy = point2.y - point1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            const baseWidth = Common.random(4, 8);
            // Calculate the width based on the current segment index, the decreasing width effect
            const width = baseWidth * (1 - i / lightningPath.length);

            // Create a thin rectangle to represent the line segment
            const lineSegment = Bodies.rectangle(
              centerX,
              centerY,
              length,
              width,
              {
                collisionFilter: {
                  category: lightningCategory,
                  mask: defaultCategory | clockCategory,
                },
                isStatic: true,
                render: {
                  fillStyle: "transparent",
                  strokeStyle: "white",
                  lineWidth: 1,
                },
              }
            );

            // Rotate the line segment to match the angle
            Body.setAngle(lineSegment, angle);
            lightningBodies.push(lineSegment);
          }

          // Add all line segments to the world
          Composite.add(lightningLayer, lightningBodies);

          // Remove the lightning after a short duration
          setTimeout(
            () => {
              Composite.remove(lightningLayer, lightningBodies);
            },
            Common.random(300, 600)
          );
        }
      }
    });
  }
</script>
