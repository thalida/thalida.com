---
import "../styles/global.css";
---

<div id="matter-container" class="w-full h-full"></div>

<style>
  #matter-container {
    display: block;
    width: 50%,
    height: 50%;
    background: #9afbda;
    background: radial-gradient(at left top, #9afbda, #ccc88b);
  }
</style>

<script>
  import {
    Engine,
    Render,
    Runner,
    Bodies,
    Body,
    Composite,
    Events,
    Common,
    Query,
    World,
  } from "matter-js";

  interface Coords {
    x: number;
    y: number;
  }

  function random(min: number = 0, max: number = 1): number {
    return Math.random() * (max - min) + min;
  }

  function debounce (callback: (...args: any[]) => void, wait: number) {
    let timeoutId: number;
    return (...args: any[]) => {
      window.clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => {
        callback(...args);
      }, wait);
    };
  }

  class MatterScene {
    element: HTMLElement | null = null;
    engine: Engine | null = null;
    world: World | null = null;
    render: Render | null = null;
    runner: Runner | null = null;

    canvasWidth: number = 800;
    canvasHeight: number = 600;

    isResizing: boolean = false;

    CATEGORIES = {
      DEFAULT: 0x0001,
      CLOCK: 0x0002,
      PERCIPITATION: 0x0004,
      LIGHTNING: 0x0008,
      ATMOSPHERIC: 0x0010,
    };

    LAYERS = {
      ATMOSPHERIC: Composite.create({
        label: "Atmospheric Layer",
      }),
      LIGHTNING: Composite.create({
        label: "Lightning Layer",
      }),
      CLOCK: Composite.create({
        label: "Clock Layer",
      }),
      PERCIPITATION: Composite.create({
        label: "Percipitation Layer",
      }),
    };

    clock: MatterClock | null = null;
    perciptiation: MatterPercipitation | null = null;
    lightning: MatterLightning | null = null;
    atmospheric: MatterAtmospheric | null = null;

    constructor() {
      this.element = document.getElementById(
        "matter-container"
      );

      if (!this.element) {
        console.error("canvas element not found");
        return;
      }

      this.engine = Engine.create({ enableSleeping: false });
      this.world = this.engine.world;

      const elementDimensions = this.element.getBoundingClientRect();

      this.canvasWidth = elementDimensions.width;
      this.canvasHeight = elementDimensions.height;

      // create a renderer
      this.render = Render.create({
        element: this.element,
        engine: this.engine,
        options: {
          width: this.canvasWidth,
          height: this.canvasHeight,
          wireframes: false,
          pixelRatio: window.devicePixelRatio || 1,
          background: "transparent", // Set background to transparent
        },
      });
      Render.run(this.render);

      // create runner
      this.runner = Runner.create();
      Runner.run(this.runner, this.engine);

      Render.lookAt(this.render, {
        min: { x: 0, y: 0 },
        max: { x: this.canvasWidth, y: this.canvasHeight },
      });

      this.drawScene();
      this.onTick();
      Render.run(this.render);

      Events.on(this.engine, "beforeUpdate", this.onTick.bind(this));
      window.addEventListener('resize', debounce(this.onResize.bind(this), 100));
    }

    drawScene() {
      if (!this.engine || !this.world || !this.render) {
        console.error("Engine, world, or render not initialized");
        return;
      }

      // Set up the world
      for (const layer of Object.values(this.LAYERS)) {
        Composite.add(this.world, layer);
      }

      // Create walls
      const WALL_THICKNESS = 6;
      const FLOOR_HEIGHT = 30;
      Composite.add(this.world, [
        Bodies.rectangle(
          this.canvasWidth / 2,
          0,
          this.canvasWidth,
          WALL_THICKNESS,
          {
            isStatic: true,
            render: { fillStyle: "transparent" },
          }
        ),
        Bodies.rectangle(
          this.canvasWidth / 2,
          this.canvasHeight,
          this.canvasWidth,
          FLOOR_HEIGHT,
          {
            isStatic: true,
            render: {
              fillStyle: "rgba(0,0,0,0.5)",
              strokeStyle: "#333",
              lineWidth: 1,
            },
          }
        ),
        Bodies.rectangle(
          0,
          this.canvasHeight / 2,
          WALL_THICKNESS,
          this.canvasHeight,
          {
            isStatic: true,
            render: { fillStyle: "transparent" },
          }
        ),
        Bodies.rectangle(
          this.canvasWidth,
          this.canvasHeight / 2,
          WALL_THICKNESS,
          this.canvasHeight,
          {
            isStatic: true,
            render: { fillStyle: "transparent" },
          }
        ),
      ]);

      this.clock = new MatterClock(this);
      this.atmospheric = new MatterAtmospheric(this);
      this.perciptiation = new MatterPercipitation(this);
      this.lightning = new MatterLightning(this);
    }

    onTick() {
      if (this.isResizing || !this.engine || !this.render) {
        return; // Ensure engine and render are initialized
      }

      this.clock?.onTick();
      this.atmospheric?.onTick();
      this.perciptiation?.onTick();
      this.lightning?.onTick();
    }

    onResize() {
      if (!this.engine || !this.world || !this.element || !this.render) {
        return; // Ensure element and render are initialized
      }

      this.isResizing = true;

      Render.stop(this.render);
      Composite.clear(this.world, false, true); // Clear the world without removing the engine

      const elementDimensions = this.element.getBoundingClientRect();

      this.canvasWidth = elementDimensions.width;
      this.canvasHeight = elementDimensions.height;
      Render.setSize(this.render, this.canvasWidth, this.canvasHeight);
      Render.setPixelRatio(this.render, window.devicePixelRatio);
      Render.lookAt(this.render, {
        min: { x: 0, y: 0 },
        max: { x: this.canvasWidth, y: this.canvasHeight },
      });

      this.drawScene();
      Render.run(this.render);

      this.isResizing = false;
    }
  }

  class MatterClock {
    scene: MatterScene;
    body: Body | Composite | (Body | Composite)[] | null = null;
    hourBody: Body | null = null;
    minuteBody: Body | null = null;
    secondBody: Body | null = null;
    handsCenterBody: Body | null = null;

    renderSeconds: boolean = true; // Whether to render seconds hand

    isDigital: boolean = false; // Whether the clock is analog or digital

    segmentComposites: Composite[] = []; // Store segment bodies for digital clock

    constructor(scene: MatterScene) {
      this.scene = scene;
      this.body = this.createBody();
      Composite.add(scene.LAYERS.CLOCK, this.body);
    }

    createBody() {
      return this.isDigital
        ? this.createDigitalBody()
        : this.createAnalogBody();
    }

    createDigitalBody() {
      const numSegments = this.renderSeconds ? 6 : 4; // Number of segments for the digital clock
      const gap = Math.min(Math.max(this.scene.canvasWidth / 30, 10), 25); // Gap between segments

      const minSegmentWidth = 20; // Minimum width for the segments
      const maxSegmentWidth = 80;
      const segmentWidth = Math.min(Math.max(
      (this.scene.canvasWidth / 1.5) / numSegments - gap,
        minSegmentWidth,
      ), maxSegmentWidth);

      const segmentHeight = segmentWidth / 4;

      const canvasCenterX = this.scene.canvasWidth / 2;
      const canvasCenterY = this.scene.canvasHeight / 2;
      const clockWidth = numSegments * segmentWidth + (numSegments - 1) * gap; // Width of the clock
      const clockHeight = (segmentWidth - segmentHeight) * 2; // Height of the clock
      const clockX =
        canvasCenterX - ((numSegments - 1) * (segmentWidth + gap)) / 2;
      const clockY = canvasCenterY - clockHeight / 2;

      const pairHues = [100, 190, 280];

      // Create segments for the digital clock
      const displayBodies = [];
      for (let i = 0; i < numSegments; i++) {
        const pairs = Math.floor(i / 2);
        const hue = pairHues[pairs % pairHues.length];

        const x = clockX + i * (segmentWidth + gap);
        const y = clockY;
        const segment = this.createDigitalSegment(
          x,
          y,
          segmentWidth,
          segmentHeight,
          {
            fillStyle: `hsl(${hue}, 20%, 70%)`, // Color for the segment
            strokeStyle: `hsl(${hue}, 20%, 90%)`, // Stroke color for the segment
          }
        );
        this.segmentComposites.push(segment);
        displayBodies.push(segment);

        const isMiddle = i % 2 === 1 && i < numSegments - 1; // Middle segments for seconds
        if (isMiddle) {
          const circleA = Bodies.circle(
            x + segmentWidth / 2 + gap / 2,
            canvasCenterY - segmentHeight,
            segmentHeight / 4,
            {
              collisionFilter: {
                category: this.scene.CATEGORIES.CLOCK,
              },
              isStatic: true,
              render: {
                fillStyle: "rgba(255,255,255,0.1)",
                strokeStyle: "rgba(255,255,255,0.4)",
                lineWidth: 1,
              },
            }
          );
          const circleB = Bodies.circle(
            x + segmentWidth / 2 + gap / 2,
            canvasCenterY + segmentHeight,
            segmentHeight / 4,
            {
              collisionFilter: {
                category: this.scene.CATEGORIES.CLOCK,
              },
              isStatic: true,
              render: {
                fillStyle: "rgba(255,255,255,0.1)",
                strokeStyle: "rgba(255,255,255,0.4)",
                lineWidth: 1,
              },
            }
          );
          displayBodies.push(circleA);
          displayBodies.push(circleB);
        }
      }

      return displayBodies;
    }

    createDigitalSegment(
      x: number,
      y: number,
      width: number,
      height: number,
      renderOptions: any
    ) {
      const combinedOptions = {
        collisionFilter: {
          category: this.scene.CATEGORIES.CLOCK,
        },
        isStatic: true,
        chamfer: { radius: height / 2 },
        render: {
          fillStyle: "transparent",
          strokeStyle: "white",
          lineWidth: 1,
          ...renderOptions, // Merge with provided render options
        },
      };
      const segmentBodyPart1 = Bodies.rectangle(x, y, width, height, {
        ...combinedOptions,
      });
      const segmentBodyPart2 = Bodies.rectangle(
        x + (width - height) / 2,
        y + (width - height) / 2,
        height,
        width,
        { ...combinedOptions }
      );
      const segmentBodyPart3 = Bodies.rectangle(
        x + (width - height) / 2,
        y + (width - height) * 1.5,
        height,
        width,
        { ...combinedOptions }
      );
      const segmentBodyPart4 = Bodies.rectangle(
        x,
        y + (width - height) * 2,
        width,
        height,
        { ...combinedOptions }
      );
      const segmentBodyPart5 = Bodies.rectangle(
        x - (width - height) / 2,
        y + (width - height) * 1.5,
        height,
        width,
        { ...combinedOptions }
      );
      const segmentBodyPart6 = Bodies.rectangle(
        x - (width - height) / 2,
        y + (width - height) / 2,
        height,
        width,
        { ...combinedOptions }
      );
      const segmentBodyPart7 = Bodies.rectangle(
        x,
        y + width - height,
        width,
        height,
        combinedOptions
      );

      const segmentComposite = Composite.create({
        label: "Segment",
        bodies: [
          segmentBodyPart1,
          segmentBodyPart2,
          segmentBodyPart3,
          segmentBodyPart4,
          segmentBodyPart5,
          segmentBodyPart6,
          segmentBodyPart7,
        ],
      });

      return segmentComposite;
    }

    createAnalogBody() {
      const minSize = Math.min(this.scene.canvasWidth, this.scene.canvasHeight);
      const clockBuffer = 50; // Buffer around the clock
      const clockRadius = (minSize - clockBuffer * 2) / 2;

      const hourHandLength = clockRadius * 0.7; // Length of the hour hand
      const minuteHandLength = clockRadius * 0.9; // Length of the minute hand
      const secondHandLength = clockRadius; // Length of the second hand
      const secondHandHitBoxLength = secondHandLength + 8; // Length of the hitbox for the second hand

      const hourHandWidth = 10; // Width of the hands
      const minuteHandWidth = 5; // Width of the hands
      const secondHandWidth = 1; // Width of the hands
      const secondHandHitBoxWidth = secondHandWidth + 8; // Width of the hitbox for the second hand

      const overlap = Math.min(Math.max(minSize / 30, 10), 30); // Gap between segments
      const centerPinSize = overlap + overlap / 2; // Size of the center pin

      this.hourBody = Bodies.rectangle(
        (this.scene.canvasWidth / 2) - (hourHandLength / 2) + overlap,
        (this.scene.canvasHeight / 2),
        hourHandLength + overlap,
        hourHandWidth,
        {
          isStatic: true,
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          render: {
            fillStyle: "transparent",
            strokeStyle: "#ddd",
            lineWidth: 1,
          },
          chamfer: {
            radius: [
              hourHandWidth / 2,
              hourHandWidth / 4,
              hourHandWidth / 4,
              hourHandWidth / 2,
            ],
          },
        }
      );
      Body.setCentre(
        this.hourBody,
        { x: hourHandLength / 2 - overlap, y: 0 },
        true
      );

      this.minuteBody = Bodies.rectangle(
        (this.scene.canvasWidth / 2) - (minuteHandLength / 2) + overlap,
        (this.scene.canvasHeight / 2),
        minuteHandLength + overlap,
        minuteHandWidth,
        {
          isStatic: true,
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          render: {
            fillStyle: "transparent",
            strokeStyle: "#ddd",
            lineWidth: 1,
          },
          chamfer: {
            radius: [
              minuteHandWidth / 2,
              minuteHandWidth / 4,
              minuteHandWidth / 4,
              minuteHandWidth / 2,
            ],
          },
        }
      );
      Body.setCentre(
        this.minuteBody,
        { x: minuteHandLength / 2 - overlap, y: 0 },
        true
      );

      if (this.renderSeconds) {
        const secondHand = Bodies.rectangle(
          (this.scene.canvasWidth / 2) - (secondHandLength / 2) + overlap,
          (this.scene.canvasHeight / 2),
          secondHandLength + overlap,
          secondHandWidth,
          {
            isStatic: true,
            collisionFilter: {
              category: this.scene.CATEGORIES.CLOCK,
            },
            render: {
              fillStyle: "transparent",
              strokeStyle: "red",
              lineWidth: 1,
            },
            chamfer: {
              radius: [
                secondHandWidth / 2,
                secondHandWidth / 4,
                secondHandWidth / 4,
                secondHandWidth / 2,
              ],
            },
          }
        );
        const secondHitBox = Bodies.rectangle(
          (this.scene.canvasWidth / 2) - (secondHandLength / 2) + overlap,
          (this.scene.canvasHeight / 2),
          secondHandHitBoxLength + overlap,
          secondHandHitBoxWidth,
          {
            isStatic: true,
            collisionFilter: {
              category: this.scene.CATEGORIES.CLOCK,
            },
            render: {
              opacity: 0.1,
              fillStyle: "white",
              strokeStyle: "transparent",
              lineWidth: 1,
            },
            chamfer: {
              radius: [
                secondHandHitBoxWidth / 2,
                secondHandHitBoxWidth / 4,
                secondHandHitBoxWidth / 4,
                secondHandHitBoxWidth / 2,
              ],
            },
          }
        );
        this.secondBody = Body.create({
          parts: [secondHand, secondHitBox],
          isStatic: true,
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
        });
        Body.setCentre(
          this.secondBody,
          { x: secondHandLength / 2 - overlap, y: 0 },
          true
        );
      }

      this.handsCenterBody = Bodies.circle(this.scene.canvasWidth / 2, this.scene.canvasHeight / 2, centerPinSize / 2, {
        isStatic: true,
        collisionFilter: {
          category: this.scene.CATEGORIES.CLOCK,
        },
        render: {
          fillStyle: "rgba(0,0,0,0.9)",
          strokeStyle: "#ddd",
          lineWidth: 2,
        },
      });

      let bodies = [this.hourBody, this.minuteBody];
      if (this.secondBody) {
        bodies.push(this.secondBody);
      }
      bodies.push(this.handsCenterBody);

      const clock = Composite.create({
        label: "Clock",
        bodies: bodies,
      });

      return clock;
    }

    onTick() {
      if (this.isDigital) {
        this.updateDigitalClock();
      } else {
        this.updateAnalogClock();
      }
    }

    updateDigitalClock() {
      if (!this.body) {
        console.error("Digital clock body not initialized");
        return;
      }

      const currentTime = new Date();
      const hours = String(currentTime.getHours()).padStart(2, "0");
      const minutes = String(currentTime.getMinutes()).padStart(2, "0");
      const seconds = String(currentTime.getSeconds()).padStart(2, "0");

      // Update the segments based on the current time
      if (this.segmentComposites.length < 4) {
        console.error("Not enough segment bodies initialized");
        return;
      }
      const hour1 = parseInt(hours[0], 10);
      const hour2 = parseInt(hours[1], 10);
      const minute1 = parseInt(minutes[0], 10);
      const minute2 = parseInt(minutes[1], 10);
      const second1 = parseInt(seconds[0], 10);
      const second2 = parseInt(seconds[1], 10);

      this.updateDigitalSegment(this.segmentComposites[0], hour1);
      this.updateDigitalSegment(this.segmentComposites[1], hour2);
      this.updateDigitalSegment(this.segmentComposites[2], minute1);
      this.updateDigitalSegment(this.segmentComposites[3], minute2);

      if (this.renderSeconds && this.segmentComposites.length > 4) {
        this.updateDigitalSegment(this.segmentComposites[4], second1);
        this.updateDigitalSegment(this.segmentComposites[5], second2);
      }
    }

    updateDigitalSegment(composite: Composite, value: number) {
      const segmentStates = [
        [1, 1, 1, 1, 1, 1, 0], // 0
        [0, 1, 1, 0, 0, 0, 0], // 1
        [1, 1, 0, 1, 1, 0, 1], // 2
        [1, 1, 1, 1, 0, 0, 1], // 3
        [0, 1, 1, 0, 0, 1, 1], // 4
        [1, 0, 1, 1, 0, 1, 1], // 5
        [1, 0, 1, 1, 1, 1, 1], // 6
        [1, 1, 1, 0, 0, 0, 0], // 7
        [1, 1, 1, 1, 1, 1, 1], //8
        [1, 1, 1, 1, 0, 1, 1], // 9
        [0, 0, 0, 0, 0, 0, 0], // Blank
      ];
      const state = segmentStates[value];
      for (let i = 0; i < composite.bodies.length; i++) {
        const segmentBody = composite.bodies[i];
        const stateValue = state[i];
        if (stateValue === 1) {
          segmentBody.collisionFilter = {
            category: this.scene.CATEGORIES.CLOCK,
            mask:
              this.scene.CATEGORIES.DEFAULT |
              this.scene.CATEGORIES.CLOCK |
              this.scene.CATEGORIES.PERCIPITATION |
              this.scene.CATEGORIES.LIGHTNING,
          };
          segmentBody.render.opacity = 0.8;
        } else {
          segmentBody.collisionFilter = {
            category: this.scene.CATEGORIES.DEFAULT,
            mask: 0, // No collisions
          };
          segmentBody.render.opacity = 0.1;
        }
      }
    }

    updateAnalogClock() {
      if (
        !this.hourBody ||
        !this.minuteBody ||
        (this.renderSeconds && !this.secondBody)
      ) {
        console.error("Clock hands not initialized");
        return;
      }

      const clockPosition = MatterClock.calculateClockAngles();
      Body.setAngle(this.hourBody, clockPosition.hour);
      Body.setAngle(this.minuteBody, clockPosition.minute);
      if (this.renderSeconds && this.secondBody) {
        Body.setAngle(this.secondBody, clockPosition.second);
      }
    }

    static calculateClockAngles() {
      const currentTime = new Date();

      const offset = 90; // Offset to align with the top of the clock

      // Calculate the angles for hour, minute, and second hands
      const hours = currentTime.getHours() % 12;
      const minutes = currentTime.getMinutes();
      const seconds = currentTime.getSeconds();
      // const hours = 6;
      // const minutes = 15;
      // const seconds = 0;

      const degreesPerHour = 360 / 12; // 12 hours on a clock
      const degreesPerMinute = 360 / 60; // 60 minutes on a clock
      const degreesPerSecond = 360 / 60; // 60 seconds on a clock

      const hourDegrees =
        hours * degreesPerHour + (minutes / 60) * degreesPerHour;
      const minuteDegrees = minutes * degreesPerMinute;
      const secondDegrees = seconds * degreesPerSecond;

      // Convert degrees to radians
      const hourRadians = (Math.PI * (hourDegrees + offset)) / 180;
      const minuteRadians = (Math.PI * (minuteDegrees + offset)) / 180;
      const secondRadians = (Math.PI * (secondDegrees + offset)) / 180;

      return {
        hour: hourRadians,
        minute: minuteRadians,
        second: secondRadians,
      };
    }
  }

  class MatterPercipitation {
    scene: MatterScene;
    layer: Composite;

    isPercipitating: boolean = true;
    percipitationType: "rain" | "snow" = "snow"; // Type of percipitation
    RAIN_FREQUENCY = 1; // Rain intensity (0 to 1)
    PERIOD_ADJUSTMENT = 0.5; // Adjustment factor for rain frequency
    MAX_BODIES = 800; // Maximum number of raindrops

    constructor(scene: MatterScene) {
      this.scene = scene;
      this.layer = this.scene.LAYERS.PERCIPITATION;
    }

    createBody() {
      return this.percipitationType === "snow"
        ? this.createSnowBody()
        : this.createRainBody();
    }

    createSnowBody() {
      const x = random(0, this.scene.canvasWidth);
      const y = 0;
      const sides = random(5, 7); // Random number of sides for the snowflake
      const radius = random(4, 8);
      const lightness = random(80, 100);
      const snowflake = Bodies.polygon(x, y, sides, radius, {
        collisionFilter: {
          category: this.scene.CATEGORIES.PERCIPITATION,
          mask:
            this.scene.CATEGORIES.DEFAULT |
            this.scene.CATEGORIES.CLOCK |
            this.scene.CATEGORIES.PERCIPITATION,
        },
        friction: 0.0001,
        frictionAir: 0.1,
        restitution: 0.3,
        density: 0.001,
        chamfer: {
          radius: radius / 4, // Chamfer the edges for a softer look
        },
        render: {
          fillStyle: `hsl(200, 50%, ${lightness}%)`,
          strokeStyle: `hsl(200, 50%, ${lightness / 2}%)`,
          lineWidth: 1,
        },
      });

      return snowflake;
    }

    createRainBody() {
      const x = random(0, this.scene.canvasWidth);
      const y = 0;
      const width = random(4, 8);
      const height = random(4, 8);
      const lightness = random(40, 70);
      const raindrop = Bodies.rectangle(x, y, width, height, {
        collisionFilter: {
          category: this.scene.CATEGORIES.PERCIPITATION,
          mask:
            this.scene.CATEGORIES.DEFAULT |
            this.scene.CATEGORIES.CLOCK |
            this.scene.CATEGORIES.PERCIPITATION,
        },
        chamfer: {
          radius: Math.min(width, height) / 2,
        },
        friction: 0.0001,
        frictionAir: 0.01,
        restitution: 0.5,
        density: 0.001,
        render: {
          fillStyle: `hsl(200, 50%, ${lightness / 2}%)`,
          strokeStyle: `hsl(200, 50%, ${lightness}%)`,
          lineWidth: 1,
        },
      });

      return raindrop;
    }

    onTick() {
      if (!this.isPercipitating) {
        return; // Skip if not raining
      }

      const frequencyCheck = random(0, 1);
      if (frequencyCheck > this.RAIN_FREQUENCY * this.PERIOD_ADJUSTMENT) {
        return; // Skip if random intensity is less than the set intensity
      }

      const currentBodies = Composite.allBodies(this.layer).length;
      if (currentBodies >= this.MAX_BODIES) {
        // Remove the oldest raindrop if the limit is reached
        Composite.remove(this.layer, Composite.allBodies(this.layer)[0]);
      }

      const raindrop = this.createBody();
      Composite.add(this.layer, raindrop);
    }
  }

  class MatterLightning {
    scene: MatterScene;
    isLightning: boolean = true;
    LIGHNING_FREQUENCY = 0.5; // Lightning intensity (0 to 1)
    PERIOD_ADJUSTMENT = 0.5; // Adjustment factor for rain frequency
    MAX_BOLTS = 10; // Maximum number of lightning bolts
    RENDER_OFFSET_X = 50;
    RENDER_OFFSET_Y = 100;

    constructor(scene: MatterScene) {
      this.scene = scene;
    }

    onTick() {
      if (!this.isLightning) {
        return; // Skip if lightning is not enabled
      }

      const numLightningBolts = Composite.allBodies(
        this.scene.LAYERS.LIGHTNING
      ).length;
      if (numLightningBolts >= this.MAX_BOLTS) {
        return;
      }

      const lightningIntensity =
        this.LIGHNING_FREQUENCY * (1 / (numLightningBolts + 1));
      const lightningCheck = random(0, 1);

      if (lightningCheck > lightningIntensity * this.PERIOD_ADJUSTMENT) {
        return; // Skip if random intensity is less than the set intensity
      }

      const startX = random(
        this.RENDER_OFFSET_X,
        this.scene.canvasWidth - this.RENDER_OFFSET_X
      );
      const startY = random(0, this.RENDER_OFFSET_Y);
      let endX = startX + random(-100, 100);
      let endY = random(
        this.scene.canvasHeight / 2,
        this.scene.canvasHeight - this.RENDER_OFFSET_Y
      );

      const clockBodies = Composite.allBodies(this.scene.LAYERS.CLOCK);
      const collisions = Query.ray(
        clockBodies,
        {
          x: startX,
          y: startY,
        },
        {
          x: endX,
          y: endY,
        },
        10
      );
      if (collisions.length > 0) {
        const smallestCollision = collisions.reduce((prev, curr) =>
          prev.supports[0].y < curr.supports[0].y ? prev : curr
        );
        endX = smallestCollision.supports[0].x;
        endY = smallestCollision.supports[0].y;
      }

      // Generate lightning bolt path points
      const lightningPath = MatterLightning.generateLightningBoltPath(
        { x: startX, y: startY },
        { x: endX, y: endY }
      );

      // Create line segments connecting each point
      const lightningBodies: Body[] = [];
      for (let i = 0; i < lightningPath.length - 1; i++) {
        const point1 = lightningPath[i];
        const point2 = lightningPath[i + 1];

        // Calculate the center point and dimensions for the line segment
        const centerX = (point1.x + point2.x) / 2;
        const centerY = (point1.y + point2.y) / 2;
        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const baseWidth = random(4, 8);

        // Calculate the width based on the current segment index, the decreasing width effect
        const width = baseWidth * (1 - i / lightningPath.length);
        const opacity = random(0.1, 0.3); // Random opacity for each segment

        // Create a thin rectangle to represent the line segment
        const lineSegment = Bodies.rectangle(centerX, centerY, length, width, {
          collisionFilter: {
            category: this.scene.CATEGORIES.LIGHTNING,
            mask:
              this.scene.CATEGORIES.DEFAULT |
              this.scene.CATEGORIES.CLOCK |
              this.scene.CATEGORIES.LIGHTNING,
          },
          isStatic: true,
          render: {
            fillStyle: `rgba(255, 255, 0, ${opacity / 2})`, // Yellow fill with random opacity
            strokeStyle: `rgba(255, 255, 0, ${opacity})`, // Yellow stroke with random opacity
            lineWidth: 1,
          },
        });

        // Rotate the line segment to match the angle
        Body.setAngle(lineSegment, angle);
        lightningBodies.push(lineSegment);
      }

      // Add all line segments to the world
      Composite.add(this.scene.LAYERS.LIGHTNING, lightningBodies);

      // Remove the lightning after a short duration
      setTimeout(
        () => {
          Composite.remove(this.scene.LAYERS.LIGHTNING, lightningBodies);
        },
        random(300, 600)
      );
    }

    static generateLightningBoltPath(startCoords: Coords, endCoords: Coords) {
      const startX = startCoords.x;
      const startY = startCoords.y;
      const endX = endCoords.x;
      const endY = endCoords.y;

      const distance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
      const segments = Math.ceil(distance / 25); // Number of segments based on distance
      const pathPoints = [];

      // Generate the main path points for the lightning line
      for (let i = 0; i <= segments; i++) {
        const progress = i / segments;
        const randomXShift = random(-20, 20);
        const x = startX + (endX - startX) * progress + randomXShift;
        const y = startY + (endY - startY) * progress;
        pathPoints.push({ x, y });
      }

      return pathPoints;
    }
  }

  class MatterAtmospheric {
    scene: MatterScene;

    isAtmospheric: boolean = true; // Whether to render atmospheric effects
    atmosphereEffect: "mist" | "clouds" = "clouds"; // Type of atmospheric effect
    ATMOSPHERIC_FREQUENCY = 0.1; // Atmospheric effect intensity (0 to 1)
    PERIOD_ADJUSTMENT = 0.5; // Adjustment factor
    MAX_BODIES = 8; // Maximum number of atmospheric bodies

    constructor(scene: MatterScene) {
      this.scene = scene;
      for (let i = 0; i < this.MAX_BODIES; i++) {
        const body = this.createBody(true);
        Composite.add(this.scene.LAYERS.ATMOSPHERIC, body);
      }
      // Atmospheric effects can be added here
    }

    createBody(isInit: boolean = false) {
      return this.atmosphereEffect === "mist"
        ? this.createMistBody(isInit)
        : this.createCloudBody(isInit);
    }

    createMistBody(isInit: boolean = false) {
      const buffer = 5; // Buffer around the mist layer
      const adjustedHeight = this.scene.canvasHeight - buffer * 2; // Adjust height for the mist layer
      const width = random(this.scene.canvasWidth / 2, this.scene.canvasWidth);
      const height = random(32, 64);
      const x = isInit
        ? random(0, this.scene.canvasWidth)
        : -1 * (width / random(1, 2)); // Start off-screen to the left
      const y = random(adjustedHeight / 1.5, adjustedHeight);
      const opacity = random(0.1, 0.2);

      const mistLayer = Bodies.rectangle(x, y, width, height, {
        isStatic: true,
        collisionFilter: {
          category: this.scene.CATEGORIES.ATMOSPHERIC,
        },
        render: {
          fillStyle: `rgba(255, 255, 255, ${opacity / 2})`, // Mist effect
          strokeStyle: `rgba(255, 255, 255, ${opacity})`, // Lighter stroke for mist
          lineWidth: 0,
        },
        chamfer: {
          radius: height / 2, // Chamfer the edges for a softer look
        },
      });

      return mistLayer;
    }

    createCloudBody(isInit: boolean = false) {
      const width = random(this.scene.canvasWidth / 2, this.scene.canvasWidth);
      const x = isInit
        ? random(0, this.scene.canvasWidth)
        : -1 * (width / random(1, 2)); // Start off-screen to the left
      const y = random(50, 150);
      const cloudParts = [];
      const numParts = Math.ceil(random(2, 4) * this.ATMOSPHERIC_FREQUENCY);
      for (let i = 0; i < numParts; i++) {
        const partWidth = random(128, 256);
        const partHeight = random(64, 128);
        const partX = x + random(-partWidth / 2, partWidth / 2);
        const partY = y + random(-partHeight / 2, partHeight / 2);
        const cloudPart = Bodies.rectangle(
          partX,
          partY,
          partWidth,
          partHeight,
          {
            isStatic: true,
            collisionFilter: {
              category: this.scene.CATEGORIES.ATMOSPHERIC,
            },
            render: {
              opacity: random(0.1, 0.2), // Random opacity for each cloud part
              fillStyle: "hsl(200, 20%, 40%)", // Cloud color
              lineWidth: 0,
            },
            chamfer: {
              radius: Math.min(partWidth, partHeight) / random(2, 4), // Chamfer the edges for a softer look
            },
          }
        );
        cloudParts.push(cloudPart);
      }

      const cloud = Body.create({
        parts: cloudParts,
        isStatic: true,
        collisionFilter: {
          category: this.scene.CATEGORIES.ATMOSPHERIC,
        },
      });
      return cloud;
    }

    onTick() {
      if (!this.isAtmospheric) {
        return; // Skip if atmospheric effects are not enabled
      }

      const bodies = Composite.allBodies(this.scene.LAYERS.ATMOSPHERIC);
      let numBodies = bodies.length;

      for (const body of bodies) {
        const x = body.position.x + random(0, 1);
        const y = body.position.y;
        Body.setPosition(body, { x, y });

        const bodyWidth = body.bounds.max.x - body.bounds.min.x;
        const bodyHeight = body.bounds.max.y - body.bounds.min.y;

        if (
          body.bounds.min.x + bodyWidth > this.scene.canvasWidth ||
          body.bounds.min.y + bodyHeight > this.scene.canvasHeight
        ) {
          numBodies--; // Decrease the count of atmospheric bodies
          if (
            body.bounds.min.x > this.scene.canvasWidth ||
            body.bounds.min.y > this.scene.canvasHeight
          ) {
            Composite.remove(this.scene.LAYERS.ATMOSPHERIC, body);
          }
        }
      }

      if (numBodies >= this.MAX_BODIES) {
        return; // Skip if the maximum number of atmospheric bodies is reached
      }
      const frequencyCheck = random(0, 1);
      if (
        frequencyCheck >
        this.ATMOSPHERIC_FREQUENCY * this.PERIOD_ADJUSTMENT
      ) {
        return; // Skip if random intensity is less than the set intensity
      }

      const newBody = this.createBody();
      Composite.add(this.scene.LAYERS.ATMOSPHERIC, newBody);
    }
  }

  const scene = new MatterScene();
</script>
