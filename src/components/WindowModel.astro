---
import "../styles/global.css";
---

<canvas id="matter-canvas" width="800" height="600"></canvas>

<script>
  import {
    Engine,
    Render,
    Runner,
    Bodies,
    Body,
    Composite,
    Events,
    Common,
    Query,
    World,
  } from "matter-js";

  interface Coords {
    x: number;
    y: number;
  }

  class MatterScene {
    canvas: HTMLCanvasElement | null = null;
    engine: Engine | null = null;
    world: World | null = null;
    render: Render | null = null;
    runner: Runner | null = null;

    canvasWidth: number = 800;
    canvasHeight: number = 600;

    CATEGORIES = {
      DEFAULT: 0x0001,
      CLOCK: 0x0002,
      PERCIPITATION: 0x0004,
      LIGHTNING: 0x0008,
    };

    LAYERS = {
      CLOCK: Composite.create({
        label: "Clock Layer",
      }),
      PERCIPITATION: Composite.create({
        label: "Percipitation Layer",
      }),
      LIGHTNING: Composite.create({
        label: "Lightning Layer",
      }),
    };

    constructor() {
      this.canvas = document.getElementById(
        "matter-canvas"
      ) as HTMLCanvasElement;

      if (!this.canvas) {
        console.error("canvas element not found");
        return;
      }

      this.engine = Engine.create({ enableSleeping: false });
      this.world = this.engine.world;
      this.canvasWidth = this.canvas.width;
      this.canvasHeight = this.canvas.height;

      // create a renderer
      this.render = Render.create({
        canvas: this.canvas,
        engine: this.engine,
        options: {
          width: this.canvasWidth,
          height: this.canvasHeight,
          wireframes: false,
          pixelRatio: window.devicePixelRatio || 1,
        },
      });
      Render.run(this.render);

      // create runner
      this.runner = Runner.create();
      Runner.run(this.runner, this.engine);

      // Set up the world
      for (const layer of Object.values(this.LAYERS)) {
        Composite.add(this.world, layer);
      }

      // Create walls
      const WALL_THICKNESS = 6;
      Composite.add(this.world, [
        Bodies.rectangle(
          this.canvasWidth / 2,
          0,
          this.canvasWidth,
          WALL_THICKNESS,
          {
            isStatic: true,
            render: { fillStyle: "transparent" },
          }
        ),
        Bodies.rectangle(
          this.canvasWidth / 2,
          this.canvasHeight,
          this.canvasWidth,
          WALL_THICKNESS,
          {
            isStatic: true,
            render: {
              fillStyle: "transparent",
              strokeStyle: "#555",
              lineWidth: 1,
            },
          }
        ),
        Bodies.rectangle(
          0,
          this.canvasHeight / 2,
          WALL_THICKNESS,
          this.canvasHeight,
          {
            isStatic: true,
            render: { fillStyle: "transparent" },
          }
        ),
        Bodies.rectangle(
          this.canvasWidth,
          this.canvasHeight / 2,
          WALL_THICKNESS,
          this.canvasHeight,
          {
            isStatic: true,
            render: { fillStyle: "transparent" },
          }
        ),
      ]);

      const clock = new MatterClock(this);
      const perciptiation = new MatterPercipitation(this);
      const lightning = new MatterLightning(this);

      clock.onTick();
      perciptiation.onTick();
      lightning.onTick();

      Render.lookAt(this.render, {
        min: { x: 0, y: 0 },
        max: { x: this.canvasWidth, y: this.canvasHeight },
      });

      Render.run(this.render);

      Events.on(this.runner, "tick", function (event) {
        // Update the clock hands every second
        if (event.timestamp % 1000 < 50) {
          clock.onTick();
        }
        lightning.onTick();
        perciptiation.onTick();
      });
    }
  }

  class MatterClock {
    scene: MatterScene;
    body: Body | Composite | (Body | Composite)[] | null = null;
    hourBody: Body | null = null;
    minuteBody: Body | null = null;
    secondBody: Body | null = null;
    handsCenterBody: Body | null = null;

    renderSeconds: boolean = true; // Whether to render seconds hand

    isDigital: boolean = false; // Whether the clock is analog or digital

    segmentComposites: Composite[] = []; // Store segment bodies for digital clock

    constructor(scene: MatterScene) {
      this.scene = scene;
      this.body = this.createBody();
      Composite.add(scene.LAYERS.CLOCK, this.body);
    }

    createBody() {
      return this.isDigital
        ? this.createDigitalBody()
        : this.createAnalogBody();
    }

    createDigitalBody() {
      const numSegments = 4; // Number of segments in the digital clock
      const gap = 25;

      const segmentWidth = 80; // Width of each segment
      const segmentHeight = 20; // Height of each segment

      const canvasCenterX = this.scene.canvasWidth / 2;
      const canvasCenterY = this.scene.canvasHeight / 2;
      const clockWidth = numSegments * segmentWidth + (numSegments - 1) * gap; // Width of the clock
      const clockHeight = (segmentWidth - segmentHeight) * 2; // Height of the clock
      const clockX =
        canvasCenterX - ((numSegments - 1) * (segmentWidth + gap)) / 2;
      const clockY = canvasCenterY - clockHeight / 2;

      // Create segments for the digital clock
      const displayBodies = [];
      for (let i = 0; i < numSegments; i++) {
        const x = clockX + i * (segmentWidth + gap);
        const y = clockY;
        const segment = this.createDigitalSegment(
          x,
          y,
          segmentWidth,
          segmentHeight
        );
        this.segmentComposites.push(segment);
        displayBodies.push(segment);

        const isMiddle = i === Math.floor(numSegments / 2);
        if (isMiddle) {
          const circleA = Bodies.circle(
            canvasCenterX,
            canvasCenterY - segmentHeight,
            segmentHeight / 4,
            {
              collisionFilter: {
                category: this.scene.CATEGORIES.CLOCK,
              },
              isStatic: true,
              render: {
                fillStyle: "transparent",
                strokeStyle: "rgba(255,255,255,0.5)",
                lineWidth: 1,
              },
            }
          );
          const circleB = Bodies.circle(
            canvasCenterX,
            canvasCenterY + segmentHeight,
            segmentHeight / 4,
            {
              collisionFilter: {
                category: this.scene.CATEGORIES.CLOCK,
              },
              isStatic: true,
              render: {
                fillStyle: "transparent",
                strokeStyle: "rgba(255,255,255,0.5)",
                lineWidth: 1,
              },
            }
          );
          displayBodies.push(circleA);
          displayBodies.push(circleB);
        }
      }

      return displayBodies;
    }

    createDigitalSegment(x: number, y: number, width: number, height: number) {
      const segmentBodyPart1 = Bodies.rectangle(x, y, width, height, {
        collisionFilter: {
          category: this.scene.CATEGORIES.CLOCK,
        },
        isStatic: true,
        chamfer: { radius: height / 2 },
        render: {
          fillStyle: "transparent",
          strokeStyle: "white",
          lineWidth: 1,
        },
      });
      const segmentBodyPart2 = Bodies.rectangle(
        x + (width - height) / 2,
        y + (width - height) / 2,
        height,
        width,
        {
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          isStatic: true,
          chamfer: { radius: height / 2 },
          render: {
            fillStyle: "transparent",
            strokeStyle: "white",
            lineWidth: 1,
          },
        }
      );
      const segmentBodyPart3 = Bodies.rectangle(
        x + (width - height) / 2,
        y + (width - height) * 1.5,
        height,
        width,
        {
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          isStatic: true,
          chamfer: { radius: height / 2 },
          render: {
            fillStyle: "transparent",
            strokeStyle: "white",
            lineWidth: 1,
          },
        }
      );
      const segmentBodyPart4 = Bodies.rectangle(
        x,
        y + (width - height) * 2,
        width,
        height,
        {
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          isStatic: true,
          chamfer: { radius: height / 2 },
          render: {
            fillStyle: "transparent",
            strokeStyle: "white",
            lineWidth: 1,
          },
        }
      );
      const segmentBodyPart5 = Bodies.rectangle(
        x - (width - height) / 2,
        y + (width - height) * 1.5,
        height,
        width,
        {
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          isStatic: true,
          chamfer: { radius: height / 2 },
          render: {
            fillStyle: "transparent",
            strokeStyle: "white",
            lineWidth: 1,
          },
        }
      );
      const segmentBodyPart6 = Bodies.rectangle(
        x - (width - height) / 2,
        y + (width - height) / 2,
        height,
        width,
        {
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          isStatic: true,
          chamfer: { radius: height / 2 },
          render: {
            fillStyle: "transparent",
            strokeStyle: "white",
            lineWidth: 1,
          },
        }
      );
      const segmentBodyPart7 = Bodies.rectangle(
        x,
        y + width - height,
        width,
        height,
        {
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          isStatic: true,
          chamfer: { radius: height / 2 },
          render: {
            fillStyle: "transparent",
            strokeStyle: "white",
            lineWidth: 1,
          },
        }
      );

      const segmentComposite = Composite.create({
        label: "Segment",
        bodies: [
          segmentBodyPart1,
          segmentBodyPart2,
          segmentBodyPart3,
          segmentBodyPart4,
          segmentBodyPart5,
          segmentBodyPart6,
          segmentBodyPart7,
        ],
      });

      return segmentComposite;
    }

    createAnalogBody() {
      const minSize = Math.min(this.scene.canvasWidth, this.scene.canvasHeight);
      const clockBuffer = 50; // Buffer around the clock
      const clockRadius = (minSize - clockBuffer * 2) / 2;

      const hourHandLength = clockRadius * 0.7; // Length of the hour hand
      const minuteHandLength = clockRadius * 0.9; // Length of the minute hand
      const secondHandLength = clockRadius; // Length of the second hand
      const secondHandHitBoxLength = secondHandLength + 8; // Length of the hitbox for the second hand

      const hourHandWidth = 10; // Width of the hands
      const minuteHandWidth = 5; // Width of the hands
      const secondHandWidth = 1; // Width of the hands
      const secondHandHitBoxWidth = secondHandWidth + 8; // Width of the hitbox for the second hand

      const overlap = 30; // Overlap between the hands and the center
      const centerPinSize = 20; // Width of the center pin

      this.hourBody = Bodies.rectangle(
        400 - hourHandLength / 2 + overlap,
        300,
        hourHandLength + overlap,
        hourHandWidth,
        {
          isStatic: true,
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          render: {
            fillStyle: "transparent",
            strokeStyle: "#ddd",
            lineWidth: 1,
          },
          chamfer: {
            radius: [
              hourHandWidth / 2,
              hourHandWidth / 4,
              hourHandWidth / 4,
              hourHandWidth / 2,
            ],
          },
        }
      );
      Body.setCentre(
        this.hourBody,
        { x: hourHandLength / 2 - overlap, y: 0 },
        true
      );

      this.minuteBody = Bodies.rectangle(
        400 - minuteHandLength / 2 + overlap,
        300,
        minuteHandLength + overlap,
        minuteHandWidth,
        {
          isStatic: true,
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
          render: {
            fillStyle: "transparent",
            strokeStyle: "#ddd",
            lineWidth: 1,
          },
          chamfer: {
            radius: [
              minuteHandWidth / 2,
              minuteHandWidth / 4,
              minuteHandWidth / 4,
              minuteHandWidth / 2,
            ],
          },
        }
      );
      Body.setCentre(
        this.minuteBody,
        { x: minuteHandLength / 2 - overlap, y: 0 },
        true
      );

      if (this.renderSeconds) {
        const secondHand = Bodies.rectangle(
          400 - secondHandLength / 2 + overlap,
          300,
          secondHandLength + overlap,
          secondHandWidth,
          {
            isStatic: true,
            collisionFilter: {
              category: this.scene.CATEGORIES.CLOCK,
            },
            render: {
              fillStyle: "transparent",
              strokeStyle: "red",
              lineWidth: 1,
            },
            chamfer: {
              radius: [
                secondHandWidth / 2,
                secondHandWidth / 4,
                secondHandWidth / 4,
                secondHandWidth / 2,
              ],
            },
          }
        );
        const secondHitBox = Bodies.rectangle(
          400 - secondHandLength / 2 + overlap,
          300,
          secondHandHitBoxLength + overlap,
          secondHandHitBoxWidth,
          {
            isStatic: true,
            collisionFilter: {
              category: this.scene.CATEGORIES.CLOCK,
            },
            render: {
              opacity: 0.1,
              fillStyle: "white",
              strokeStyle: "transparent",
              lineWidth: 1,
            },
            chamfer: {
              radius: [
                secondHandHitBoxWidth / 2,
                secondHandHitBoxWidth / 4,
                secondHandHitBoxWidth / 4,
                secondHandHitBoxWidth / 2,
              ],
            },
          }
        );
        this.secondBody = Body.create({
          parts: [secondHand, secondHitBox],
          isStatic: true,
          collisionFilter: {
            category: this.scene.CATEGORIES.CLOCK,
          },
        });
        Body.setCentre(
          this.secondBody,
          { x: secondHandLength / 2 - overlap, y: 0 },
          true
        );
      }

      this.handsCenterBody = Bodies.circle(400, 300, centerPinSize / 2, {
        isStatic: true,
        collisionFilter: {
          category: this.scene.CATEGORIES.CLOCK,
        },
        render: {
          fillStyle: "rgba(0,0,0,0.9)",
          strokeStyle: "#ddd",
          lineWidth: 2,
        },
      });

      let bodies = [this.hourBody, this.minuteBody];
      if (this.secondBody) {
        bodies.push(this.secondBody);
      }
      bodies.push(this.handsCenterBody);

      const clock = Composite.create({
        label: "Clock",
        bodies: bodies,
      });

      return clock;
    }

    onTick() {
      if (this.isDigital) {
        this.updateDigitalClock();
      } else {
        this.updateAnalogClock();
      }
    }

    updateDigitalClock() {
      if (!this.body) {
        console.error("Digital clock body not initialized");
        return;
      }

      const currentTime = new Date();
      const hours = String(currentTime.getHours()).padStart(2, "0");
      const minutes = String(currentTime.getMinutes()).padStart(2, "0");
      const seconds = String(currentTime.getSeconds()).padStart(2, "0");

      // Update the segments based on the current time
      if (this.segmentComposites.length < 4) {
        console.error("Not enough segment bodies initialized");
        return;
      }
      const hour1 = parseInt(hours[0], 10);
      const hour2 = parseInt(hours[1], 10);
      const minute1 = parseInt(minutes[0], 10);
      const minute2 = parseInt(minutes[1], 10);

      this.updateDigitalSegment(this.segmentComposites[0], hour1);
      this.updateDigitalSegment(this.segmentComposites[1], hour2);
      this.updateDigitalSegment(this.segmentComposites[2], minute1);
      this.updateDigitalSegment(this.segmentComposites[3], minute2);
    }

    updateDigitalSegment(composite: Composite, value: number) {
      const segmentStates = [
        [1, 1, 1, 1, 1, 1, 0], // 0
        [0, 1, 1, 0, 0, 0, 0], // 1
        [1, 1, 0, 1, 1, 0, 1], // 2
        [1, 1, 1, 1, 0, 0, 1], // 3
        [0, 1, 1, 0, 0, 1, 1], // 4
        [1, 0, 1, 1, 0, 1, 1], // 5
        [1, 0, 1, 1, 1, 1, 1], // 6
        [1, 1, 1, 0, 0, 0, 0], // 7
        [1, 1, 1, 1, 1, 1, 1], //8
        [1, 1, 1, 1, 0, 1, 1], // 9
        [0, 0, 0, 0, 0, 0, 0], // Blank
      ];
      const state = segmentStates[value];
      for (let i = 0; i < composite.bodies.length; i++) {
        const segmentBody = composite.bodies[i];
        const stateValue = state[i];
        if (stateValue === 1) {
          segmentBody.collisionFilter = {
            category: this.scene.CATEGORIES.CLOCK,
            mask:
              this.scene.CATEGORIES.DEFAULT |
              this.scene.CATEGORIES.CLOCK |
              this.scene.CATEGORIES.PERCIPITATION |
              this.scene.CATEGORIES.LIGHTNING,
          };
          segmentBody.render.opacity = 1; // Show the segment
          segmentBody.render.fillStyle = "rgba(255,255,255,0.2)"; // Set the segment color
          segmentBody.render.strokeStyle = "white"; // Set the segment stroke color
          segmentBody.render.lineWidth = 1; // Set the segment stroke width
        } else {
          segmentBody.collisionFilter = {
            category: this.scene.CATEGORIES.DEFAULT,
            mask: 0, // No collisions
          };
          segmentBody.render.opacity = 0.2; // Hide the segment
          segmentBody.render.fillStyle = "transparent"; // Set the segment color to transparent
        }
      }
    }

    updateAnalogClock() {
      if (
        !this.hourBody ||
        !this.minuteBody ||
        (this.renderSeconds && !this.secondBody)
      ) {
        console.error("Clock hands not initialized");
        return;
      }

      const clockPosition = MatterClock.calculateClockAngles();
      Body.setAngle(this.hourBody, clockPosition.hour);
      Body.setAngle(this.minuteBody, clockPosition.minute);
      if (this.renderSeconds && this.secondBody) {
        Body.setAngle(this.secondBody, clockPosition.second);
      }
    }

    static calculateClockAngles() {
      const currentTime = new Date();

      const offset = 90; // Offset to align with the top of the clock

      // Calculate the angles for hour, minute, and second hands
      const hours = currentTime.getHours() % 12;
      const minutes = currentTime.getMinutes();
      const seconds = currentTime.getSeconds();
      // const hours = 6;
      // const minutes = 15;
      // const seconds = 0;

      const degreesPerHour = 360 / 12; // 12 hours on a clock
      const degreesPerMinute = 360 / 60; // 60 minutes on a clock
      const degreesPerSecond = 360 / 60; // 60 seconds on a clock

      const hourDegrees =
        hours * degreesPerHour + (minutes / 60) * degreesPerHour;
      const minuteDegrees = minutes * degreesPerMinute;
      const secondDegrees = seconds * degreesPerSecond;

      // Convert degrees to radians
      const hourRadians = (Math.PI * (hourDegrees + offset)) / 180;
      const minuteRadians = (Math.PI * (minuteDegrees + offset)) / 180;
      const secondRadians = (Math.PI * (secondDegrees + offset)) / 180;

      return {
        hour: hourRadians,
        minute: minuteRadians,
        second: secondRadians,
      };
    }
  }

  class MatterPercipitation {
    scene: MatterScene;
    layer: Composite;

    isRaining: boolean = true;
    RAIN_FREQUENCY = 0.1; // Rain intensity (0 to 1)
    MAX_BODIES = 1000; // Maximum number of raindrops

    constructor(scene: MatterScene) {
      this.scene = scene;
      this.layer = this.scene.LAYERS.PERCIPITATION;
    }

    createBody() {
      const x = Common.random(0, this.scene.canvasWidth);
      const y = 0;
      const width = Common.random(2, 4);
      const height = Common.random(4, 8);
      const lightness = Common.random(40, 70);
      const raindrop = Bodies.rectangle(x, y, width, height, {
        collisionFilter: {
          category: this.scene.CATEGORIES.PERCIPITATION,
          mask:
            this.scene.CATEGORIES.DEFAULT |
            this.scene.CATEGORIES.CLOCK |
            this.scene.CATEGORIES.PERCIPITATION,
        },
        chamfer: {
          radius: Math.min(width, height) / 2,
        },
        friction: 0.0001,
        frictionAir: 0.01,
        restitution: 0.5,
        density: 0.001,
        render: {
          fillStyle: "transparent",
          lineWidth: 1,
          strokeStyle: `hsl(200, 50%, ${lightness}%)`,
        },
      });

      return raindrop;
    }

    onTick() {
      if (!this.isRaining) {
        return; // Skip if not raining
      }

      const frequencyCheck = Common.random(0, 1);
      if (frequencyCheck > this.RAIN_FREQUENCY) {
        return; // Skip if random intensity is less than the set intensity
      }

      const currentBodies = Composite.allBodies(this.layer).length;
      if (currentBodies >= this.MAX_BODIES) {
        // Remove the oldest raindrop if the limit is reached
        Composite.remove(this.layer, Composite.allBodies(this.layer)[0]);
      }

      const raindrop = this.createBody();
      Composite.add(this.layer, raindrop);
    }
  }

  class MatterLightning {
    scene: MatterScene;
    isLightning: boolean = true;
    LIGHNING_FREQUENCY = 0.01; // Lightning intensity (0 to 1)
    MAX_BOLTS = 10; // Maximum number of lightning bolts
    RENDER_OFFSET_X = 50;
    RENDER_OFFSET_Y = 100;

    constructor(scene: MatterScene) {
      this.scene = scene;
    }

    onTick() {
      if (!this.isLightning) {
        return; // Skip if lightning is not enabled
      }

      const numLightningBolts = Composite.allBodies(
        this.scene.LAYERS.LIGHTNING
      ).length;
      if (numLightningBolts >= this.MAX_BOLTS) {
        return;
      }

      const lightningIntensity =
        this.LIGHNING_FREQUENCY * (1 / (numLightningBolts + 1));
      const lightningCheck = Common.random(0, 1);

      if (lightningCheck > lightningIntensity) {
        return; // Skip if random intensity is less than the set intensity
      }

      const startX = Common.random(
        this.RENDER_OFFSET_X,
        this.scene.canvasWidth - this.RENDER_OFFSET_X
      );
      const startY = Common.random(0, this.RENDER_OFFSET_Y);
      let endX = startX + Common.random(-100, 100);
      let endY = Common.random(
        this.scene.canvasHeight / 2,
        this.scene.canvasHeight - this.RENDER_OFFSET_Y
      );

      const clockBodies = Composite.allBodies(this.scene.LAYERS.CLOCK);
      const collisions = Query.ray(
        clockBodies,
        {
          x: startX,
          y: startY,
        },
        {
          x: endX,
          y: endY,
        }
      );
      if (collisions.length > 0) {
        // If the lightning intersects with the clock, adjust the end point
        const collisionPoint = collisions[0].supports[0];
        endX = collisionPoint.x;
        endY = collisionPoint.y;
      }

      // Generate lightning bolt path points
      const lightningPath = MatterLightning.generateLightningBoltPath(
        { x: startX, y: startY },
        { x: endX, y: endY }
      );

      // Create line segments connecting each point
      const lightningBodies: Body[] = [];
      for (let i = 0; i < lightningPath.length - 1; i++) {
        const point1 = lightningPath[i];
        const point2 = lightningPath[i + 1];

        // Calculate the center point and dimensions for the line segment
        const centerX = (point1.x + point2.x) / 2;
        const centerY = (point1.y + point2.y) / 2;
        const dx = point2.x - point1.x;
        const dy = point2.y - point1.y;
        const length = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        const baseWidth = Common.random(4, 8);
        // Calculate the width based on the current segment index, the decreasing width effect
        const width = baseWidth * (1 - i / lightningPath.length);

        // Create a thin rectangle to represent the line segment
        const lineSegment = Bodies.rectangle(centerX, centerY, length, width, {
          collisionFilter: {
            category: this.scene.CATEGORIES.LIGHTNING,
            mask:
              this.scene.CATEGORIES.DEFAULT |
              this.scene.CATEGORIES.CLOCK |
              this.scene.CATEGORIES.LIGHTNING,
          },
          isStatic: true,
          render: {
            fillStyle: "transparent",
            strokeStyle: "white",
            lineWidth: 1,
          },
        });

        // Rotate the line segment to match the angle
        Body.setAngle(lineSegment, angle);
        lightningBodies.push(lineSegment);
      }

      // Add all line segments to the world
      Composite.add(this.scene.LAYERS.LIGHTNING, lightningBodies);

      // Remove the lightning after a short duration
      setTimeout(
        () => {
          Composite.remove(this.scene.LAYERS.LIGHTNING, lightningBodies);
        },
        Common.random(300, 600)
      );
    }

    static generateLightningBoltPath(startCoords: Coords, endCoords: Coords) {
      const startX = startCoords.x;
      const startY = startCoords.y;
      const endX = endCoords.x;
      const endY = endCoords.y;

      const distance = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
      const segments = Math.ceil(distance / 25); // Number of segments based on distance
      const pathPoints = [];

      // Generate the main path points for the lightning line
      for (let i = 0; i <= segments; i++) {
        const progress = i / segments;
        const randomXShift = Common.random(-20, 20);
        const x = startX + (endX - startX) * progress + randomXShift;
        const y = startY + (endY - startY) * progress;
        pathPoints.push({ x, y });
      }

      return pathPoints;
    }
  }

  const scene = new MatterScene();
</script>
